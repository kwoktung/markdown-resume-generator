---
description: API routing and service layer architecture standards
globs: ["src/app/api/**/*", "src/services/**/*"]
alwaysApply: true
---

# API Routing and Service Layer Standards

## API Route Organization

### 1. Route Location
- **All new API routes (except auth) MUST be defined in `src/app/api/services/[...rest]/`**
- Auth routes are handled separately in `src/app/api/auth/[...nextauth]/route.ts`
- Each feature domain should have its own file (e.g., `document.ts`, `user.ts`, `upload.ts`)

### 2. OpenAPI Schema Definition
New routes **MUST** define comprehensive OpenAPI schemas using Zod and `@hono/zod-openapi`:

#### Request Schemas
Define schemas for:
- Request body (`createDocumentSchema`, `updateDocumentSchema`)
- URL parameters (using `z.object` with transformations)
- Query parameters (using `z.object` with optional fields)

#### Response Schemas
Define schemas for:
- Success responses (`createDocumentResponseSchema`, `getDocumentResponseSchema`)
- List/paginated responses (`listDocumentsResponseSchema`)
- Error responses (401, 404, 500, etc.)

#### Route Definition
Use `createRoute` from `@hono/zod-openapi` to define:
- HTTP method (`method: "get" | "post" | "put" | "delete"`)
- Path pattern (e.g., `"/"`, `"/{id}"`, `"/{id}/duplicate"`)
- Request validation (body, params, query)
- Response documentation with status codes and descriptions

**Example Structure:**
```typescript
const createDocument = createRoute({
  method: "post",
  path: "/",
  request: {
    body: {
      content: {
        "application/json": {
          schema: createDocumentSchema,
        },
      },
    },
  },
  responses: {
    200: {
      description: "Success",
      content: {
        "application/json": {
          schema: createDocumentResponseSchema,
        },
      },
    },
    401: { description: "Unauthorized - User not authenticated" },
    400: { description: "Bad request - Invalid data" },
  },
});
```

### 3. Service Layer Organization

**Related business logic MUST be defined in `src/services/`:**
- Create a corresponding service class for each API feature domain
- Service files should mirror API route files (e.g., `document.ts` API â†’ `document.ts` service)
- Services should extend `BaseService` class
- Services handle all database operations and business logic

**Example Service Structure:**
```typescript
export class DocumentService extends BaseService {
  constructor(ctx: Context) {
    super(ctx);
  }

  async getDocuments(userId: string, limit?: number, offset?: number) {
    // Database operations
  }

  async createDocument(documentData: Omit<NewDocument, "id" | "createdAt">) {
    // Business logic
  }
}
```

## Implementation Pattern

### API Route Handler (src/app/api/services/[...rest]/)
1. Import required schemas and services
2. Define Zod schemas for validation
3. Define OpenAPI routes with `createRoute`
4. Create `OpenAPIHono` app instance
5. Implement route handlers with:
   - Session authentication check
   - Request validation (`c.req.valid()`)
   - Service instantiation
   - Business logic delegation to service layer
   - Response formatting

### Service Layer (src/services/)
1. Define type exports (`Document`, `NewDocument`)
2. Extend `BaseService`
3. Implement business methods
4. Handle database operations using Drizzle ORM
5. Return typed results

## Key Principles

- **Separation of Concerns**: API routes handle HTTP/validation, services handle business logic
- **Type Safety**: Use TypeScript types inferred from database schema
- **Authentication**: Always check session before processing requests (except public endpoints)
- **Error Handling**: Return appropriate HTTP status codes with descriptive messages
- **Documentation**: OpenAPI schemas serve as living API documentation
- **Validation**: Use Zod schemas for runtime validation and type inference

## Reference Files

- API Route Example: `src/app/api/services/[...rest]/document.ts`
- Service Layer Example: `src/services/document.ts`
